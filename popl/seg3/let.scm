#lang racket

(require eopl)

(provide core-scan core-parse core-eval-expr)

; Primitive functions and their evaluators
(define primitives (list
  (cons "zero?" zero?)
  (cons "minus" (lambda (x) (- 0 x)))

  (cons "+" +)
  (cons "-" -)
  (cons "*" *)
  (cons "/" /)
  (cons "equal?"   equal?)
  (cons "greater?" >)
  (cons "less?"    <)
))

; Lexical specification
(define lexer-spec '(
  ; Skip all whitespace
  (white (whitespace) skip)

  ; Integers
  (number (digit (arbno digit)) number)

  ; Identifiers
  (identifier ((or letter "+" "-" "*" "/") (arbno (or letter digit "?"))) string)
))

; Grammar specification
(define grammar-spec '(
  ; Primitive number expression
  (expression (number) expr-number)

  ; Generic compound expression
  (expression (identifier "(" (separated-list expression ",") ")") expr-compound)

  ; Conditional
  (expression ("if" expression "then" expression "else" expression) expr-if)
))

; Define datatypes from the grammar
(sllgen:make-define-datatypes lexer-spec grammar-spec)

; Create parsers
(define core-scan  (sllgen:make-string-scanner lexer-spec grammar-spec))
(define core-parse (sllgen:make-string-parser  lexer-spec grammar-spec))

; Evaluate compound expression
(define (eval-compound type exprs)
  ; Get operator
  (let ((oper-pair (assoc type primitives)))
    (if oper-pair
      ; Accepting the correct number of args?
      (if (procedure-arity-includes? (cdr oper-pair) (length exprs))
        ; OK, execute function over evaluated expressions
        (apply (cdr oper-pair) (map core-eval-expr exprs))

        ; Bad argument count
        (eopl:error 'core-arg-count "Wrong number of arguments for operator ~s" type)
      )

      ; Bad operator
      (eopl:error 'core-undefined "Undefined operator ~s" type)
    )
  )
)

; Evaulates an expression tree generated by (core-parse)
(define (core-eval-expr tree)
  (cases expression tree
    ; Numeric expression
    (expr-number (num) num)

    ; Conditional
    (expr-if (expr true false)
             (if (core-eval-expr expr) (core-eval-expr true) (core-eval-expr false)))

    ; Compound expression
    (expr-compound (type exprs) (eval-compound type exprs))
))
