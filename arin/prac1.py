'''
ARIN Practical 1 Ex 3 code

James Cowgill

Generate search tree for water-jug problem
... try running solve()
'''

# Parmeters used in Ex2
CAN_FILL = False
JUGS = (8, 3, 2)
INITIAL = (8, 0, 0)
goal_test = lambda state: state[2] == 1

# Traditional parameters
#CAN_FILL = True
#JUGS = (5, 3)
#INITIAL = (0, 0)
#goal_test = lambda state: state[0] == 4

################################################################

# Range used for ids in the list of jugs
_JUGS_RANGE = range(0, len(JUGS))

def expand_level(initial):
    '''
    Expands the treee by one level

    initial = current state of this tree node
    returns a list of tuples containing the possible next states
    '''

    result = []

    # Discarding water from the current state
    for i in _JUGS_RANGE:
        if initial[i] != 0:
            lst = list(initial)
            lst[i] = 0
            result.append(tuple(lst))

    # Filling up jugs
    if CAN_FILL:
        for i in _JUGS_RANGE:
            if initial[i] != JUGS[i]:
                lst = list(initial)
                lst[i] = JUGS[i]
                result.append(tuple(lst))

    # Moving water (from i to j)
    for i in _JUGS_RANGE:
        if initial[i] != 0:
            for j in _JUGS_RANGE:
                if i != j and initial[j] != JUGS[j]:
                    lst = list(initial)
                    move_amount = min(initial[i], JUGS[j] - initial[j])
                    lst[i] -= move_amount
                    lst[j] += move_amount
                    result.append(tuple(lst))

    return result

def expand_levels(initial,amount):
    '''
    Expands multiple levels of the tree

    Unlike expand_level, this returns a tuple containing
    (previous state, list of next states), and recursive, like a tree
    '''

    # Expand one level
    result = expand_level(initial)

    # Recurse for more levels
    if amount > 1:
        for i in range(0, len(result)):
            result[i] = expand_levels(result[i], amount - 1)

    return (initial, result)

def print_tree(result, indent=''):
    '''Prints a tree generated by expand_levels'''

    # Is this a leaf node?
    if hasattr(result[0], '__getitem__'):
        # Print root
        out_str = indent + '- ' + str(result[0])
        if goal_test(result[0]):
            out_str += ' <--- GOAL'
        print out_str

        # Print children
        for child in result[1]:
            print_tree(child, indent + '  ')
    else:
        # Print leaf
        out_str = indent + '- ' + str(result)
        if goal_test(result):
            out_str += ' <--- GOAL'
        print out_str

def tree_search(tree):
    '''
    Searches a tree for a result

    no result found = returns None
    result found = returns a list of states in REVERSE
    '''

    # Is this a leaf node?
    if hasattr(tree[0], '__getitem__'):
        # Goal state?
        if goal_test(tree[0]):
            return [tree]

        # Try children
        for child in tree[1]:
            child_result = tree_search(child)
            if child_result:
                child_result.append(tree[0])
                return child_result
    else:
        # Goal state?
        if goal_test(tree):
            return [tree]

    return None

def solve(initial = INITIAL):
    '''
    Searches the parse tree for the first goal state found

    Prints the solution found.
    This will probably be quite slow for large problems...
    '''

    i = 1
    while True:
        print "Trying level", i

        # Run iterative depth first scan
        solution = tree_search(expand_levels(INITIAL, i))
        if solution:
            solution.reverse()
            print "Solution found at level", i
            print "List of states: "
            for state in solution:
                print " -", state
            return

        i += 1
